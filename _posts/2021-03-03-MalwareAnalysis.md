---
title: Malware Analysis using Radare2
layout: posts
author: Divya
---
## Breaking down infections for fun. Exploring r2 while exploring the first ever discovered malware for Apple M1 chips.

### Brief intro
Malware has been a predominant threat to computers, networks, and infrastructures for decades now. Detecting these
pieces of nuisances has been an ordeal as malware analysts are coming about with new and improvised ways to detect and
nip them in the bud before they create destruction.

### Discovering newly designed ones in the Wild
Detecting previously attacked malware can be easy based on signature or anomaly. Storing their signature in databases,
developing rules based on typical behaviours of such malicious code has been proved efficient thus far.

> What about the newer ones?

### Noticing weird behaviour in your system? Get the app, we are going to do some reversing today.
**I will be using the newest and the first malware discovered in the wild for Apple M1 Chips :)
Details about the malware can be found here (Thanks to virustotal!): [GoSearch22](https://www.virustotal.com/gui/file/b94e5666d0afc1fa49923c7a7faaa664f51f0581ec0192a08218d68fb079f3cf/detection)**

<br>As you can now see GoSearch is an "adware", meaning it is capable of hijacking the settings of the mac device and
causes automatic redirection to specific webpages. Works for all major browsers(Like Safari, Firefox, Chrome).
Watch carefully the /details section to get a quick view of what it is (more revealed to you in this blog)
<br><br>*For the more curious ones, feel free to continue to the graph feature where you will get a better representation
of the calls made by the file.*
---

### First things fist. Verify what type of file do we have here:
```
┬─[divya at racharch in ~/a/b/r/mldt]
╰──> λ file sample
sample: Mach-O universal binary with 2 architectures: [x86_64:Mach-O 64-bit x86_64 executable, flags:<NOUNDEFS|DYLDLINK|TWOLEVEL|PIE>] [arm64:Mach-O 64-bit arm64 executable, flags:<NOUNDEFS|DYLDLINK|TWOLEVEL|PIE>]
```
> [Note: If you were curious about what universal binaries are: [We can be friends!](https://developer.apple.com/documentation/xcode/building_a_universal_macos_binary)]

### We have our sample. Let's start exploring
*   Let's unpack it on radare2. Fire up r2, let's start with the simplest syntax with no flags:

```
┬─[divya at racharch in ~/a/b/r/mldt]
╰──> λ r2 sample 
[0x100001d20]>
```
*   Before we begin, `?` command:
to get a brief description of what a command can do use the command followed with a ?. Like:

```
[0x100001d20]> ?
Usage: [.][times][cmd][~grep][@[@iter]addr!size][|>pipe] ; ...
Append '?' to any char command to get detailed help
Prefix with number to repeat command N times (f.ex: 3x)
| %var=value              alias for 'env' command
| *[?] off[=[0x]value]    pointer read/write data/values (see ?v, wx, wv)
| (macro arg0 arg1)       manage scripting macros
| .[?] [-|(m)|f|!sh|cmd]  Define macro or load r2, cparse or rlang file
```

*   Before we start viewing different areas, we need to make sure r2 has finished analyzing the whole binary.
You can also interpret this as r2 should know ***what*** is ***where***. We run the aa command twice. 

> [Note: Again, if ever in doubt on the command, go ahead and see what `aa?` says about it.]

```
[0x100001d20]>aaaa
[x] Analyze all flags starting with sym. and entry0 (aa)
[x] Analyze function calls (aac)
[x] Analyze len bytes of instructions for references (aar)
[x] Check for objc references
[x] Parsing metadata in ObjC to find hidden xrefs
[x] Found 0 objc xrefs in 122 dwords.
[x] Check for vtables
[x] Type matching analysis for all functions (aaft)
[x] Propagate noreturn information
[x] Use -AA or aaaa to perform additional experimental analysis.
[x] Finding function preludes
[x] Enable constraint types analysis for variables
[0x100001d20]> #done!
```

> [Note: This might not be a thorough tutorial of r2, I will be walking through the useful ones. You can always find
> more on [r2book](https://book.rada.re)]

*   Now that our binary is analyzed, let's find out more info on our binary. We do it with the info command `i`:

```
[0x100001d20]> iI?
| iI                 Binary info
[0x100001d20]> iI
arch     x86
baddr    0x100000000
binsz    414368
bintype  mach0
bits     64
canary   true
class    MACH064
crypto   false
endian   little
havecode true
intrp    /usr/lib/dyld
laddr    0x0
lang     objc with blocks
linenum  false
lsyms    false
machine  x86 64 all
maxopsz  16
minopsz  1
nx       false
os       macos
pcalign  0
pic      true
relocs   false
sanitiz  false
static   false
stripped true
subsys   darwin
va       true
```
We are done with our first scan on GoSearch using r2!

*   Now that we have the info, we can look in the insides. Let's list all the analyzed functions inside the binary.

```
[0x100001d20]> afl?
Usage: afl   List all functions
| afl            list functions
| afl.           display function in current offset (see afi.)
| afl+           display sum all function sizes
[0x100001d20]> afl
0x100001d20   90 4333         entry0
0x100053410    1 6            sym.imp.CC_MD5
0x100053416    1 6            sym.imp.CGEventSourceSecondsSinceLastEventType
0x10005341c    1 6            sym.imp.CGSessionCopyCurrentDictionary
0x100053422    1 6            sym.imp.IOObjectRelease
0x100053428    1 6            sym.imp.IORegistryEntryCreateCFProperty
0x10005342e    1 6            sym.imp.IOServiceGetMatchingService
0x100053434    1 6            sym.imp.IOServiceMatching
0x10005343a    1 6            sym.imp.NSSetUncaughtExceptionHandler
0x100053440    1 6            sym.imp.NSTemporaryDirectory
0x100053446    1 6            sym.imp.SCDynamicStoreCopyConsoleUser
0x10005344c    1 6            sym.imp._Block_object_assign
0x100053452    1 6            sym.imp._Block_object_dispose
0x100053458    1 6            sym.imp._Unwind_Resume
0x10005345e    1 6            sym.imp.__bzero
0x100053464    1 6            sym.imp.__stack_chk_fail
0x10005346a    1 6            sym.imp.class_getName
0x100053470    1 6            sym.imp.dispatch_async
0x100053476    1 6            sym.imp.dispatch_get_global_queue
0x10005347c    1 6            sym.imp.dispatch_once
0x100053482    1 6            sym.imp.dispatch_once_f
0x100053488    1 6            sym.imp.dispatch_semaphore_create
0x10005348e    1 6            sym.imp.dispatch_semaphore_signal
0x100053494    1 6            sym.imp.dispatch_semaphore_wait
0x10005349a    1 6            sym.imp.dispatch_time
0x1000534a0    1 6            sym.imp.dlopen
0x1000534a6    1 6            sym.imp.dlsym
```

*   Like every executable, a malware has ways of importing data and exporting them to other places. 
Should we want to see those, we use `i` again. 

<br> We see the exports using `e`(for entrypoints) and `E`(for exports).

```
[0x100001d20]> iE?
| iE                 Exports (global symbols)
| iE.                Current export
[0x100001d20]> ie?
| ie                 Entrypoint
| iee                Show Entry and Exit (preinit, init and fini)
[0x100001d20]> ieE
[Entrypoints]
vaddr=0x100001d20 paddr=0x00002d20 haddr=0x000009b8 type=program

1 entrypoints
[Exports]

nth paddr       vaddr       bind   type size lib name
―――――――――――――――――――――――――――――――――――――――――――――――――――――
0    0x00001000 0x100000000 GLOBAL FUNC 0        __mh_execute_header
```
For viewing imports or API calls to different locations of the system, we use `i`.
```
[0x100001d20]> ii?
| ii                 Imports
[0x100001d20]> ii
[Imports]
nth vaddr       bind type           lib name
――――――――――――――――――――――――――――――――――――――――――――
0   0x100053410 NONE FUNC               CC_MD5
1   0x100053416 NONE FUNC               CGEventSourceSecondsSinceLastEventType
2   0x10005341c NONE FUNC               CGSessionCopyCurrentDictionary
3   0x100053422 NONE FUNC               IOObjectRelease
4   0x100053428 NONE FUNC               IORegistryEntryCreateCFProperty
5   0x10005342e NONE FUNC               IOServiceGetMatchingService
6   0x100053434 NONE FUNC               IOServiceMatching
7   0x10005343a NONE FUNC               NSSetUncaughtExceptionHandler
8   0x100053440 NONE FUNC               NSTemporaryDirectory
9   0x00000000  NONE OBJC_CLASS         NSApplication
10  0x00000000  NONE OBJC_CLASS         NSArray
11  0x00000000  NONE OBJC_CLASS         NSBundle
12  0x00000000  NONE OBJC_CLASS         NSCharacterSet
13  0x00000000  NONE OBJC_CLASS         NSDate
14  0x00000000  NONE OBJC_CLASS         NSDateFormatter
15  0x00000000  NONE OBJC_CLASS         NSDictionary
16  0x00000000  NONE OBJC_CLASS         NSException
17  0x00000000  NONE OBJC_CLASS         NSFileHandle
18  0x00000000  NONE OBJC_CLASS         NSFileManager
19  0x00000000  NONE OBJC_CLASS         NSJSONSerialization
20  0x00000000  NONE OBJC_CLASS         NSMutableString
21  0x00000000  NONE OBJC_CLASS         NSMutableURLRequest
22  0x00000000  NONE OBJC_CLASS         NSNumber
23  0x00000000  NONE OBJC_CLASS         NSObject
```

*   Travel to a different region, let's change the seek!

There are several things you can do with r2. As we are done with a basic info gathering around our sample. We can now
try walking around different areas and see in detail what a section of the code looks like. Seek command or `s` is made
exactly for this. Viewing at the different API calls we select one and move to the section where it is actually
imported.

```
[0x100001d20]> s?
Usage: s    # Help for the seek commands. See ?$? to see all variables
| s                 Print current address
| s.hexoff          Seek honoring a base from core->offset
| s:pad             Print current address with N padded zeros (defaults to 8)
| s addr            Seek to address
[0x100001d20]> ii~IOServiceMatching
6   0x100053434 NONE FUNC               IOServiceMatching
[0x100001d20]> s 0x100053434
[0x100053434]> #seek address changed!
```
Notice the change in the seek pointer? Now we are at the point of the code where the IOServiceMatching API is geting
called. How do we know? It is dissassembly time!

```
[0x100053434]> pd?
Usage: p[dD][ajbrfils] [len]   # Print Disassembly
| NOTE: len        parameter can be negative
| NOTE:            Pressing ENTER on empty command will repeat last print command in next page
| pD N             disassemble N bytes
| pd -N            disassemble N instructions backward
| pd N             disassemble N instructions
| pd--[n]          context disassembly of N instructions
| pda[?]           disassemble all possible opcodes (byte per byte)
| pdb              disassemble basic block
| pdc              pseudo disassembler output in C-like syntax
[0x100053434]> pdc
function sym.imp.IOServiceMatching () {
    //  1 basic blocks

    loc_0x100053434:

         //CALL XREFS from sym.func.100004600 @ 0x1000049d9, 0x1000050ef
       goto qword [reloc.IOServiceMatching] //[0x100057090:8]=0x10005373e ; ">7\x05"
(break)

}
[0x100053434]> pdf
            ; CALL XREFS from sym.func.100004600 @ 0x1000049d9, 0x1000050ef
            ;-- rip:
┌ 6: sym.imp.IOServiceMatching ();
│ bp: 0 (vars 0, args 0)
│ sp: 0 (vars 0, args 0)
│ rg: 0 (vars 0, args 0)
└           0x100053434      ff25563c0000   jmp qword [reloc.IOServiceMatching] ; [0x100057090:8]=0x10005373e ; ">7\x05"
[0x100053434]> pds
;-- rip:
0x100053434 ">7\x05"
0x10005343a "T5\x05"
0x100053440 "^5\x05"
0x100053446 "H7\x05"
0x100053464 "&6\x05"
0x10005346a "h5\x05"
0x100053470 "06\x05"
0x100053476 ":6\x05"
0x10005347c "D6\x05"
0x100053482 "N6\x05"
0x100053488 "X6\x05"
0x10005348e "b6\x05"
0x100053494 "l6\x05"
0x10005349a "v6\x05"
0x1000534dc "r5\x05"
0x1000534e2 "|5\x05"
;-- section.2.__TEXT.__stub_helper:
0x100053544 [02] -r-x section size 526 named 2.__TEXT.__stub_helper
```
